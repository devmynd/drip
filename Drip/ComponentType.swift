/**
 Classes conforming to `ComponentType` are a container for a set of dependencies,
 declared in `Modules`, and are the principal mechanism for scoping dependencies
 to particular part of the application.
 
 A `ComponentType` owns modules, which can be registered through the chainable
 method `module`.
*/
public protocol ComponentType: class {
  /**
   The `registry` is used as the component's backing store. Conformance to
   `ComponentType` only requires that the implementer declare storage for and
   construct a registry.
  */
  var registry: Registry { get }
}

// MARK: Parents
public extension ComponentType {
  /**
   Retrieves a registered parent component. If the parent component is not yet
   registerd, this method raises an exception.

   - Returns: A pre-registered parent of type `P`
  */
  func parent<P: ComponentType>() -> P {
    do {
      return try registry.get()
    } catch Error.ComponentNotFound(let type) {
      terminate("failed to find parent: \(type)")
    } catch {
      terminate()
    }
  }

  /**
   Registers a parent component of type `P`. This component can be retrieved through
   the `parent` accessor method.

   - Parameter initializer: A closure called immediately that returns or initializes
     the parent, which is then discarded.

   - Returns: This component for chaining
  */
  func parent<P: ComponentType>(initializer: () -> P) -> Self {
    registry.set(initializer())
    return self
  }
}

// MARK: Modules
public extension ComponentType {
  /**
   Retrieves the module registered for the module type `M`. If no module has been
   registerd for `M`, this method raises an exception.
   
   `M` must decare this component as it's `Owner`.

   - Returns: A pre-registered module of type `M`
  */
  func module<M: ModuleType where M.Owner == Self>() -> M {
    do {
      return try registry.get()
    } catch Error.ModuleNotFound(let type) {
      terminate("failed to find module \(type)")
    } catch {
      terminate()
    }
  }

  /**
   Registers a module of type `M`. This module can be retrieved through the `module` 
   accessor method.
   
   - Parameter type: The supertype (or the type itself) of the module to register
   - Parameter initializer: A closure called immediately that returns or initializes
   the module, which is then discarded. Passed this component as its only parameter.

   - Returns: This component for chaining
  */
  func module<M: ModuleType where M.Owner == Self>(type: M.Type, initializer: (Self) -> M) -> Self {
    registry.set(type, value: initializer(self))
    return self
  }
}

// MARK: Overrides
public extension ComponentType {
  /**
   Overrides the registered factory for type `T` to return a single instance.

   - Parameter instance: The instance to return whenever a `T` is injected
   - Returns: This component for chaining
  */
  func override<T>(instance: T) -> Self {
    return override { _ in instance }
  }

  /**
   Overrides the registered factory for the factory's `Element`.

   - Parameter factory: The factory to use whenever `T` is injected
   - Returns: This component for chaining
  */
  func override<F: FactoryType where F.Component == Self>(factory: F) -> Self {
    return override(factory.create)
  }

  /**
   Overrides the registered factory for type `T`. Instances are generated by
   calling the `generator`.

   - Parameter factory: The generator to call whenever a `T` is injected
   - Returns: This component for chaining
  */
  func override<T>(generator: (Self) -> T) -> Self {
    registry.set(generator)
    return self
  }
}

// MARK: Factories
extension ComponentType {
  func resolve<F: FactoryType where F.Component == Self>(constructor: () -> F) -> F.Element {
    return lazyGeneratorFor(constructor)(self)
  }

  private func lazyGeneratorFor<F: FactoryType where F.Component == Self>(constructor: () -> F) -> (Self) -> F.Element {
    var result: (Self) -> F.Element

    if let generator: (Self) -> F.Element = registry.get() {
      result = generator
    } else {
      result = constructor().create
      registry.set(result)
    }

    return result
  }
}

// MARK: Errors
extension ComponentType {
  @noreturn func terminate(message: String = "unknown error") {
    fatalError("[component: \(self)] \(message)")
  }
}